Getting Started
===============

Creating the session
--------------------

In order to interact with the SMC ReST API, you must first obtain a valid login session. 
The session is generated by authenticating an API Client and the associated authentication key.

Once the login session has been retrieved successfully, all commands or controls will reuse 
the same session. 

When exiting, call `smc.api.web.logout()` to remove the active session from the SMC.

.. note:: Idle API sessions will still time out after a default (configurable) amount of time

Steps to enable API Communication on the Stonesoft Management Center:

#. Enable SMC API service on the properties of the Management Server
#. Create an API Client and obtain the 'authentication key'

Once you have enabled this and have access to the authentication key (keep this safe), 
you can establish a session to the SMC by either providing the url and apikey in the 
constructor, or storing this in a file located ~/.smcrc.

Example of providing the connect information through the constructor:

.. code-block:: python

   from smc import session

   session.login(url='http://1.1.1.1:8082', api_key='EiGpKD4QxlLJ25dbBEp20001')
   ....do stuff....
   session.logout()

If a specific API version is requested, you can add the following argument to the login
constructor. Otherwise the latest API version available will be used:

.. code-block:: python

   from smc import session
   session.login(url='http://1.1.1.1:8082', api_key='EiGpKD4QxlLJ25dbBEp20001', 
   api_version='5.10')

In order to use SSL connections, you must first associated a private key and certificate
with the SMC API server. This is done under the Management Server properties, SMC API.
Obtain the certificate for use by the client.
It is recommended to ensure your certificate has the subjectAltName field set per
RFC 2818.

Using SSL and specify certificate for verifying:

.. code-block:: python

   from smc import session
   session.login(url='https://1.1.1.1:8082', api_key='EiGpKD4QxlLJ25dbBEp20001', 
   				 verify='/Users/davidlepage/home/mycacert.pem')
   
Using SSL to the SMC without SSL validation (NOT recommended)

.. code-block:: python

   from smc import session
   session.login(url='https://1.1.1.1:8082', api_key='EiGpKD4QxlLJ25dbBEp20001',
   				 verify=False)

When storing in a file, using session.login with no arguments:

.. code-block:: python
	
	session.login()
	session.logout()

If storing in a user profile configuration file, the syntax is:

.. code-block:: python

   [smc]
   smc_address=1.1.1.1
   smc_apikey=xxxxxxxxxxxxxxxxxxxxxxxxx
   smc_port=8082 (optional; default:8082)
   smc_cert='/Users/davidlepage/home/mycacert.pem'
   ssl_on
   
Once the session has been successfully obtained, there is no reason to re-authenticate a new session
unless `logout` has been called.

.. note:: If you have a longer running application where the session may time out due to long delays 
		  between calls, the smc-python API will re-authenticate the session automatically as long as a previous 
		  session was already obtained and stored in the session cache.

To enable logging from smc-python, a convenience method is provided to show stream logging:

.. code-block:: python

   from smc import set_stream_logger
   set_stream_logger(level=logging.DEBUG, format_string=None)

Resources
---------

Resources are specific areas within the smc-python API that require 'load' actions to retrieve the 
configuration data and encapsulate specific methods based on the element type. The intent of elements that
require load() be called is to use a cached instance of the element.
For example, to perform actions against a specific engine within SMC, you must first identify the engine and
load the configuration:

.. code-block:: python

   engine = Engine('myengine').load()
   
Once the engine is loaded, all methods for that engine and engine nodes are provided in the resulting 
engine references.

A list of current resources are:

* Engine: encapsulates all engine types; :py:class:`smc.elements.engine.Engine`

Much of the functionality is encapsulated into these top level resources. For example, after loading 
a VPNPolicy, you can add external endpoints (for External Gateways), add VPN Sites, enable/disable sites, etc.

Other elements such as network elements can be retrieved by referencing the element type directly, or
by using describe methods to get the context of the element. 

For example, getting the available host elements through collections:

.. code-block:: python

   for host in describe_hosts():
       print host.name, host.href

Or by accessing directly if the host name is known:

.. code-block:: python

   host = Host('myhost')
   print host.describe()
   
.. code-block:: python

   policy = FirewallPolicy('firewall-perimeter')
   for rule in policy.fw_ipv4_access_rules.all():
       print rule

Collection
----------

Collections are functions provided to return base level information about a 
specific SMC element by type :py:mod:`smc.elements.collection`
Some collection types have additional filters that can be used to get more specific 
results.

Each collection returns meta data for each element type consisting of 3 attributes:

* name: name of element
* type: type of element
* href: href to location of element

The class container returned will not have the full element details but will provide a 
linkage to retrieving them.

To search for all host objects:

.. code-block:: python

   for host in collection.describe_hosts():
       print host
        
To search only for a host name 'test':

.. code-block:: python

   for host in collection.describe_hosts(name=['test']):
       print host

To search for all hosts with 'test' in the name:

.. code-block:: python

   for host in collection.describe_hosts(name=['test'], exact_match=False):
       print host
   
Creating elements
-----------------

Elements within the Stonesoft Management Server are common object types that are referenced
by other configurable areas of the system such as policy, routing, VPN, etc. 

Creating elements with smc-python can be done for all of the common element types:

* Hosts
* AddressRange
* Networks
* Routers
* Groups
* DomainName
* IPList (SMC API >= 6.1)
* URLListApplication (SMC API >= 6.1)
* Zone
* LogicalInterface
* TCPService
* UDPService
* IPService
* EthernetService
* ServiceGroup
* TCPServiceGroup
* UDPServiceGroup
* IPServiceGroup
* ICMPService
* ICMPv6Service

Oftentimes these objects are cross referenced within the configuration, like when creating rule or
NAT policy.
All calls to create() will return an :py:class:`smc.api.web.SMCResult` which will hold the attributes
necessary to determine if the creation was successful, and if not, the reason. The href attribute will
have the new HREF for the created object and msg attribute will hold an error message, if any.

Examples of creating elements are as follows:

.. code-block:: python

   from smc.elements.element import Host, Router, Network, AddressRange, Group, Service
   
   AddressRange.create('myrange', '10.0.0.1-10.0.0.254')
   Host.create('myhost', '192.168.1.1', secondary_ip='192.168.1.2')
   Router.create('defaultgw', '172.18.1.1', comment='internet facing gw')
   Network.create('vpn network', '10.10.1.0/24')
   
   Group.create('group')  #no members
   Group.create('group', members=['1.1.1.1','1.1.1.2'])
   
   TCPService.create('tcp666', 666)
   UDPService.create('udp5000-5001', 5000, 5001)
  
See the :py:class:`smc.elements.element` reference documentation for more specific details.

Modifying elements
------------------   

It is possible to modify elements after creation by calling the classmethod modify of each
element.
Once called, the json attribute will have the existing settings for the object type and can
be modified. After making modifications to the object attributes, call update() to update the
element on the SMC.

Example of modifying a TCPServiceGroup by changing the name:

.. code-block:: python
   
   tcp = TCPService.create('newservice', 6000) #create a new tcp service
   for service in describe_tcp_services():
     if service.name == 'api-tcpgrp2':
       service.modify_attribute(name='mynew-servicename')
 
Example of adding TCP and UDP Services to an existing Service Group:

.. code-block:: python
   
   udp = UDPService.create('api-udp-svc', 6000)
   tcp = TCPService.create('api-tcp-svc', 6000)
   for group in describe_tcp_service_groups([name='api-servicegrp']):
     group.modify_attribute(element=[udp.href, tcp.href])

Example of changing an existing Host and IP address:

.. code-block:: python

   for host in describe_hosts(name=['myhost']):
     h.modify_attribute(name='kiley', address='1.1.2.2')

Empty out all members of a specific network element group:

.. code-block:: python
   
   for groups in describe_groups():
     if group.name == 'mygroup':
       group.modify_attribute(element=[member1, member2]
            
If modification was successful, SMCResult will have the href attribute set with the location of
the element, or the msg attribute set with reason if modification fails.
   
Creating engines
----------------

Engines are the definitions for a layer 3 FW, layer 2 FW, IPS, Cluster Firewalls, Master Engines,
or Virtual Engines.

An engine defines the basic settings to make the device or virtual instance operational such as
interfaces, routes, ip addresses, networks, dns servers, etc. 

Creating engines are done using the Firewall specific base classes in :py:mod:`smc.core.engines`

Nodes are individual devices represented as properties of an engine element. 
In the case of single device deployments, there is only one node. For clusters, there will be at a minimum 
2 nodes, max of 16. The :py:mod:`smc.elements.engines:node` class represents the interface to managing and 
sending commands individually to a node in a cluster. 

By default, each constructor will have default values for the interface used for management (interface 0).
This can be overridden as necessary.

Creating Layer3 Firewall
++++++++++++++++++++++++

For Layer 3 single firewall engines, the minimum requirements are to specify a name, management IP and
management network. By default, the Layer 3 firewall will use interface 0 as the management port. This can
be overridden in the constructor if a different interface is required. 

To create a layer 3 firewall:

.. code-block:: python

   from smc.core.engines import Layer3Firewall
   
   Layer3Firewall.create('myfirewall', '1.1.1.1', '1.1.1.0/24')

See reference for more information: :py:class:`smc.elements.engines.Layer3Firewall`

Creating Layer 2 Firewall
+++++++++++++++++++++++++

For Layer 2 Firewall and IPS engines, an inline interface pair will automatically be 
created using interfaces 1-2 but can be overridden in the constructor to use different
interface mappings.

Creating a Layer2 Firewall with alternative management interface and DNS settings:

.. code-block:: python

   from smc.core.engines import Layer2Firewall
   
   Layer2Firewall.create('myfirewall', '1.1.1.1', '1.1.1.0/24', mgmt_interface=5, dns=['172.18.1.20'])

See reference for more information: :py:class:`smc.elements.engines.Layer2Firewall`
   									  
Creating IPS engine
+++++++++++++++++++

Using alternative inline interface pair (mgmt on interface 0):
 
 .. code-block:: python

    from smc.core.engines import IPS
   
    IPS.create('myfirewall', '1.1.1.1', '1.1.1.0/24', inline_interface='5-6')
 
Once you have created your engine, it is possible to use any of the engine or node level commands
to control the nodes.

See reference for more information: :py:class:`smc.elements.engines.IPS`

Creating Master Engine
++++++++++++++++++++++

A Master Engine is used to manage virtual engine nodes and provides in system virtualization.
Master Engine controls administrative aspects and specifies how resources are allocated to 
the virtual engines.

Create a master engine with a single management interface, then add 2 more physical interface for
virtual engine allocation:

.. code-block:: python

   engine = MasterEngine.create(name='api-master',
                       			mgmt_ip='1.1.1.1',
                       			mgmt_netmask='1.1.1.0/24',
                       			master_type='firewall', 
                       			domain_server_address=['8.8.4.4', '7.7.7.7'])
                       
   engine.physical_interface.add(interface_id=1)
   engine.physical_interface.add(interface_id=2)
   

See :py:class:`smc.core.engines.MasterEngine` for more details.

Creating Layer3Virtual Engine
+++++++++++++++++++++++++++++

A virtual engine is a host that resides on a Master Engine node used for multiple FW contexts. Stonesoft
maps a 'virtual resource' to a virtual engine as a way to map the master engine interface to the individual
instance residing within the physical device. 

In order to create a virtual engine, you must first manually create the Master Engine from the SMC, then 
create the interfaces that will be used for the virtual instances.

The first step in creating the virtual engine is to create the virtual resource and map that to a physical interface
or VLAN on the master engine. Once that has been created, add IP addresses to the virtual engine interfaces as necessary.

To create the virtual resource:

.. code-block:: python
        
   		engine.virtual_resource_add(virtual_engine_name='ve-1', vfw_id=1)
           
See :py:func:`smc.elements.engine.Engine.virtual_resource_add` for more information.

Creating a layer 3 virtual engine with 3 physical interfaces:
        
.. code-block:: python
        
   Layer3VirtualEngine.create(
   				   name='red',
   				   master_engine='my_master_engine', 
   				   virtual_resource='ve-1',
                   interfaces=[
                            {'address': '5.5.5.5', 'network_value': '5.5.5.5/30', 'interface_id':0},
                            {'address': '6.6.6.6', 'network_value': '6.6.6.0/24', 'interface_id':1},
                            {'address': '7.7.7.7', 'network_value': '7.7.7.0/24', 'interface_id':2}]

.. note:: Virtual engine interface id's will be staggered based on used interfaces
          by the master engine.
          For example, if the master engine is using physical interface 0 for 
          management, the virtual engine may be assigned physical interface 1 
          for use. From an indexing perspective, the naming within the virtual engine 
          configuration will start at interface 0 but be using physical interface 1.

See reference for more information: :py:class:`smc.elements.engines.Layer3VirtualEngine`
                            
Creating Firewall Cluster
+++++++++++++++++++++++++

Creating a layer 3 firewall cluster requires additional interface related information to bootstrap the
engine properly.
With NGFW clusters, a "cluster virtual interface" is required (if only one interface is used) to specify 
the cluster address as well as each engine specific node IP address. In addition, a macaddress is required 
for packetdispatch functionality (recommended HA configuration).

By default, the FirewallCluster class will allow as many nodes as needed (up to 16 per cluster) for the
singular interface. The node specific interfaces are defined by passing in the 'nodes' argument to the
constructor as follows:

.. code-block:: python

   engine = FirewallCluster.create(name='mycluster', 
                                    cluster_virtual='1.1.1.1', 
                                    cluster_mask='1.1.1.0/24',
                                    cluster_nic=0,
                                    macaddress='02:02:02:02:02:02',
                                    nodes=[{'address': '1.1.1.2', 'network_value': '1.1.1.0/24', 'nodeid':1},
                                           {'address': '1.1.1.3', 'network_value': '1.1.1.0/24', 'nodeid':2},
                                           {'address': '1.1.1.4', 'network_value': '1.1.1.0/24', 'nodeid':3}],
                                    domain_server_address=['1.1.1.1'], 
                                    zone_ref=zone_helper('Internal'))
                             

Creating MasterEngine Cluster
+++++++++++++++++++++++++++++

Create a master engine cluster for redundancy. Master Engine clusters support active/standby
mode.

Create the cluster and add a second interface for each cluster node:

.. code-block:: python

   engine = MasterEngineCluster.create(
                                    name='engine-cluster',
                                    master_type='firewall', 
                                    macaddress='22:22:22:22:22:22', 
                                    nodes=[{'address':'5.5.5.2', 
                                            'network_value':'5.5.5.0/24', 
                                            'nodeid':1},
                                           {'address':'5.5.5.3', 
                                            'network_value':'5.5.5.0/24', 
                                            'nodeid':2}])
      
   #Create another interface
   engine.physical_interface.add_cluster_interface_on_master_engine(
                                    interface_id=1,
                                    macaddress='22:22:22:22:22:33', 
                                    nodes=[{'address': '6.6.6.2',
                                            'network_value': '6.6.6.0/24',
                                            'nodeid':1},
                                            {'address':'6.6.6.3',
                                             'network_value':'6.6.6.0/24',
                                             'nodeid':2}])
                                             
See :py:class:`smc.core.engines.MasterEngineCluster` for more info
                                 
Interfaces
++++++++++

After your engine has been successfully created with the default interfaces, you can add and remove 
interfaces as needed.

From an interface perspective, there are several different interface types that are have subtle differences.
The supported physical interface types available are:

* Single Node Dedicated Interface (Single Layer 3 Firewall)
* Node Dedicated Interface (Used on Clusters, IPS, Layer 2 Firewall)
* Inline Interface (IPS / Layer2 Firewall)
* Capture Interface (IPS / Layer2 Firewall)
* Cluster Virtual Interface 
* Virtual Physical Interface (used for Layer 3 Virtual Engines)
* Tunnel Interface

The distinction is subtle but straightforward. A single node interface is used on a single layer 3 firewall
instance and represents a unique interface with dedicated IP Address.

A node dedicated interface is used on Layer 2 and IPS engines as management based interfaces and may also be used as
a heartbeat (for example). 

It is a unique IP address for each machine. It is not used for operative traffic in Firewall Clusters, 
IPS engines, and Layer 2 Firewalls. 
Firewall Clusters use a second type of interface, Cluster Virtual IP Address (CVI), for operative traffic. 

IPS engines have two types of interfaces for traffic inspection: the Capture Interface and the Inline Interface. 
Layer 2 Firewalls only have Inline Interfaces for traffic inspection.

.. note:: When creating your engine instance, the correct type/s of interfaces are created automatically
          without having to specify the type. However, this will be relavant when adding interfaces to an
          existing device after creation.

To access interface information on existing engines, or to add to an existing engine, you must first load the
engine context configuration. It is not required to know the engine type (layer3, layer2, ips) as you can load 
by the parent class :py:class:`smc.elements.engines.Engine`.

For example, if I know I have an engine named 'myengine' (despite the engine 'role'), it can be
loaded via:

.. code-block:: python

    from smc.elements.engines import Engine
    
    engine = Engine('myengine').load()
	
It is not possible to add certain interface types based on the node type. For example, it is not 
possible to add inline or capture interfaces to layer 3 FW engines. However, this is handled
automatically by the SMC API and SMCResult will indicate whether the operation/s succeeds or fails
and why.

Adding interfaces are handled by property methods on the engine class. 

To add a single node interface to an existing engine as Interface 10:

.. code-block:: python

   engine = Engine('myengine').load()
   engine.physical_interface.add_single_node_interface(10, '33.33.33.33', '33.33.33.0/24')

Node Interface's are used on IPS, Layer2 Firewall, Virtual and Cluster Engines and represent either a
single interface or a cluster member interface used for communication.

To add a node interface to an existing engine:

.. code-block:: python

   engine = Engine('myengine').load()
   engine.physical_interface.add_node_interface(10, '32.32.32.32', '32.32.32.0/24')
   
Inline interfaces can only be added to Layer 2 Firewall or IPS engines. An inline interface consists
of a pair of interfaces that do not necessarily have to be contiguous. Each inline interface requires
that a 'logical interface' is defined. This is used to identify the interface pair and can be used to
simplify policy. See :py:class:`smc.elements.element.LogicalInterface` for more details.

To add an inline interface to an existing engine:

.. code-block:: python

   logical_interface = logical_intf_helper('MyLogicalInterface') #get logical interface reference
   engine = Engine('myengine').load()
   engine.physical_interface.add_inline_interface('5-6', logical_interface_ref=logical_intf)
   
.. note:: Use :py:func:`smc.elements.element.logical_intf_helper('name')` which will find the existing
		  logical interface reference or create the logical interface automatically
		     
Capture Interfaces are used on Layer 2 Firewall or IPS engines as SPAN monitors to view traffic on the wire. 
   
To add a capture interface to a layer2 FW or IPS:

.. code-block:: python

   logical_interface = logical_intf_helper('MyLogicalInterface')
   engine = Engine('myengine').load()
   engine.physical_interface.add_capture_interface(10, logical_interface_ref=logical_interface)

Cluster Virtual Interfaces are used on clustered engines and require a defined "CVI" (sometimes called a 'VIP'),
as well as node dedicated interfaces for the engine initiated communications. Each clustered interface will therefore
have 3 total address for a cluster of 2 nodes. 

To add a cluster virtual interface on a layer 3 FW cluster:

.. code-block:: python
   
   engine.physical_interface.add_cluster_virtual_interface(
                                 interface_id=1,
                                 cluster_virtual='5.5.5.1', 
                                 cluster_mask='5.5.5.0/24', 
                                 macaddress='02:03:03:03:03:03', 
                                 nodes=[{'address':'5.5.5.2', 'network_value':'5.5.5.0/24', 'nodeid':1},
                                        {'address':'5.5.5.3', 'network_value':'5.5.5.0/24', 'nodeid':2},
                                        {'address':'5.5.5.4', 'network_value':'5.5.5.0/24', 'nodeid':3}],
                                 zone_ref=zone_helper('Heartbeat'))

.. warning:: Make sure the cluster virtual netmask matches the node level networks
                                           
Nodes specified are the individual node dedicated addresses for the cluster members.

VLANs can be applied to layer 3 or inline interfaces. For inline interfaces, these will not have assigned
IP addresses, however layer 3 interfaces will require addressing as a routed device.

To add a VLAN to a generic physical interface for single node (layer 3 firewall) or a node interface, 
independent of engine type:

.. code-block:: python

   engine = Engine('myengine').load()
   engine.physical_interface.add_vlan_to_node_interface(23, 154)
   engine.physical_interface.add_vlan_to_node_interface(23, 155)
   engine.physical_interface.add_vlan_to_node_interface(23, 156)

This will add 3 VLANs to physical interface 23. If this is a layer 3 routed firewall, you may still need
to add addressing to each VLAN. 

.. note:: In the case of Virtual Engines, it may be advisable to create the physical interfaces with 
	      VLANs on the Master Engine and allocate the IP addressing scheme to the Virtual Engine.
	      

To add layer 3 interfaces with a VLAN and IP address:

.. note:: The physical interface will be created if it doesn't already exist

.. code-block:: python
   
   engine = Engine('myengine').load()
   engine.physical_interface.add_single_node_interface_to_vlan(2, '3.3.3.3', '3.3.3.0/24', 
                                               vlan_id=3, zone_ref=zone_helper('Internal')
   
To add VLANs to layer 2 or IPS inline interfaces:

.. note:: The physical interface will be created if it doesn't already exist

.. code-block:: python
   
   logical_interface = logical_intf_helper('default_eth') #find logical intf or create it
   engine = Engine('myengine').load()
   engine.physical_interface.add_vlan_to_inline_interface('5-6', 56, 
                                                          logical_interface_ref=logical_interface)
   engine.physical_interface.add_vlan_to_inline_interface('5-6', 57, 
                                                          logical_interface_ref=logical_interface)
   engine.physical_interface.add_vlan_to_inline_interface('5-6', 58, 
                                                          logical_interface_ref=logical_interface)
   
To see additional information on interfaces, :py:class:`smc.elements.interfaces` reference documentation 

Deleting Interfaces
+++++++++++++++++++

Deleting interfaces is done at the engine level. In order to delete an interface, you must first call
load() on the engine to get the context of the engine.

Once you have loaded the engine, you can display all available interfaces by calling using the 
engine level property interface:
:py:func:`smc.elements.engine.Engine.interface` to view all interfaces for the engine.

The name of the interface is the name the NGFW gives the interface based on interface index. For example, 
physical interface 1 would be "Interface 1" and so on.

To view all assigned interfaces to the engine:

.. code-block:: python

   engine = Engine('engine').load()
   for interface in engine.interface.all():
     print interface.name, interface.type
     
Deleting an assigned layer 3 physical interface:

.. code-block:: python

   engine = Engine('myfirewall').load()
   for interface in engine.interface.all():
     if interface.name = 'Interface 2':
       interface.delete()

To see additional information on interfaces, :py:class:`smc.elements.interfaces` reference documentation

Modifying Interfaces
++++++++++++++++++++

To modify an existing interface, you can specify key/value pairs to change specific settings. This should be
used with care as changing existing settings may affect other settings. For example, when an interface is 
configured with an IP address, the SMC will automatically create a route entry mapping that physical interface
to the directly connected network. Changing the IP will leave the old network definition from the previously
assigned interface and would need to be removed. 

Example of changing the IP address of an existing single node interface (for layer 3 firewalls):

.. code-block:: python

   engine = Engine('myfirewall').load()
   for interface in engine.interface.all():
     if interface.name == 'Interface 2':
       my_interface = interface.describe()
       my_interface.modify_attribute({zone_ref:'My New Zone'})
       
.. note:: Key/value pairs can be viewed by viewing the output of
          interface.describe()

Adding routes
+++++++++++++

Adding routes to routed interfaces is done by loading the engine and providing the next hop
gateway and destination network as parameters. It is not necessary to specify the interface
to place the route, the mapping will be done automatically on the SMC based on the existing
IP addresses and networks configured on the engine. 

For example, load a Layer 3 Firewall and add a route:

.. code-block:: python

   engine = Engine('myengine').load()
   engine.add_route('172.18.1.254', '192.168.1.0/24')
   engine.add_route('172.18.1.254', '192.168.2.0/24')

Licensing Engines
+++++++++++++++++

Stonesoft engine licensing for physical appliances is done by having the SMC 'fetch' the license
POS from the appliance and auto-assign the license. If the engine is running on a platform that doesn't
have a POS (Proof-of-Serial) such as a virtual platform, then the fetch will fail. In this case, it is 
possible to do an auto bind which will look for unassigned dynamic licenses available in the SMC.

Example of attempting an auto-fetch and falling back to auto binding a dynamic license:

.. code-block:: python
   
   engine = Engine('myvirtualfw').load()
   for node in engine:
     result = engine.bind_license() #try to find POS, then dynamic license
     if not result.msg:
       print "Success with auto binding of license"

Controlling engines
-------------------

Managed engines have many options for controlling the behavior of the device or virtual through
the SMC API. Once an engine has been created, in order to execute specific commands against the 
engine or a node within an engine configuration, you must first 'load' the engine configuration to
get a handle on that device. 

.. note:: Commanding a single engine does not require a specific node is specified for node level commands

There are two levels to which you can control and engine. This is represented by the class
hierarchy:

Engine ---> Node

Engine level commands allow operations like refresh policy, upload new policy, generating snapshots,
export configuration, blacklisting, adding routes, route monitoring, and add or delete a physical interfaces.

.. code-block:: python

   engine = Engine('myengine').load()
   engine.generate_snapshot() #generate a policy snapshot
   engine.export(filename='/Users/davidlepage/export.xml') #generate policy export
   engine.refresh() #refresh policy
   engine.routing_monitoring() 	#get route table status
   ....

For all available commands for engines, see :py:class:`smc.elements.engines.Engine`
   
Node level commands are specific commands targeted at the engine nodes directly. In the case of a cluster, 
most node level commands require sending node=<nodename> to each constructor. This is to enforce a command is
targeting a specific node such as the case with sending the 'reboot' command for example.

Node level commands allow actions such as fetch license, bind license, initial contact, appliance status, 
go online, go offline, go standby, lock online, lock offline, reset user db, diagnostics, reboot, sginfo, 
ssh (enable/disable/change pwd), and time sync.

.. code-block:: python

   engine = Engine('myengine').load()
   for node in engine.nodes:
     print node
   
   for node in engine.nodes:
     if node.name == 'ngf-1035':
       node.reboot()

Bind license, then generate initial contact for each node for a specific engine:

.. code-block:: python
   
   for node in engine.nodes:
     node.initial_contact(filename='/Users/davidlepage/engine.cfg')	#gen initial contact and save to engine.cfg
     node.bind_license()	#bind license on single node

For all available commands for node, see :py:class:`smc.elements.engines.Node`

Policies
--------

To create a new policy:

.. code-block:: python

   FirewallPolicy.create('newpolicy', 'template=href_to_template')
   
Getting the template is easiest through the collection.describe_* methods

.. code-block:: python

   import smc.elements.collection
   for template in describe_fw_template_policy():
     print template.name, template.href
   
To load an existing policy type:

.. code-block:: python

   FirewallPolicy('existing_policy_by_name')
        
Example rule creation:

.. code-block:: python

   policy = FirewallPolicy('newpolicy')
   policy.fw_ipv4_access_rules.create(name='mynewrule', sources='any', 
                                      destinations='any', services='any',
                                      action='permit')

See :py:mod:`smc.examples.firewall_policy` for a full example 

Create a NAT rule for a firewall policy using source NAT (outbound NAT example):

.. code-block:: python

   for policy in describe_fw_policy():
     if policy.name == 'Datacenter Policy':
       policy.fw_ipv4_nat_rules.create(name='mynatrule', 
                                       sources='any', 
                                       destinations='any', 
                                       services='any',
                                       dynamic_src_nat='10.0.0.245')
                                    
For additional NAT related options, see: :py:class:`smc.policy.rule.IPv4NATRule`

VPN Policy
----------

It is possible to create a VPN policy for SMC managed devices or for creating a 
VPN to a non-SMC managed external gateway.

An ExternalGateway defines a host that is not a managed VPN peer endpoint.

A full setup of a VPN policy would look like:

.. code-block:: python

   external_gateway = ExternalGateway.create('myextgw')
    
 
An external endpoint is defined within the external gateway and specifies the
IP address settings and other VPN specific settings for this endpoint
After creating, add to the external gateway

.. code-block:: python

   external_endpoint = ExternalEndpoint.create(name='myendpoint', 
                                               address='2.2.2.2')
   external_gateway.add_external_endpoint(external_endpoint)
    
Lastly, 'sites' need to be configured that identify the network/s on the
other end of the VPN. You can either use pre-existing network elements, or create
new ones as in the example below.
Then add this site to the external gateway

.. code-block:: python

   network = Network.create('remote-network', '1.1.1.0/24').href
    
   external_gateway.add_site('remote-site', [network])

Retrieve the internal gateway for SMC managed engine by loading the
engine configuration. The internal gateway reference is located as
engine.internal_gateway.href

.. code-block:: python

   engine = Engine('aws-02').load()

Create the VPN Policy
    
.. code-block:: python

   vpn = VPNPolicy.create(name='myVPN', nat=True)
   print vpn.name, vpn.vpn_profile
    
   vpn.open()
   vpn.add_central_gateway(engine.internal_gateway.href)
   vpn.add_satellite_gateway(external_gateway.href)
   vpn.save()
   vpn.close()

See :py:mod:`smc.examples.vpn_to_external` for a full example 

Creating Administrators
-----------------------

Creating administrators and modifying settings can be done using the 
:py:class:`smc.elements.user.AdminUser` class.

For example, to create a user called 'administrator' and modify after creation, do:

Create admin:

.. code-block:: python

   admin = AdminUser.create('administrator')
   if admin.href:
     print "Successfully created admin"
     
To modify after creation by setting a password and making a superuser:

.. code-block:: python

   admin = AdminUser('administrator')
   admin.change_password('mynewpassword')
   admin.modify_attribute(superuser=True)
   admin.enable_disable() #enable or disable account
    
Search
------

Searching is typically done by leveraging convenience methods found in :py:mod:`smc.actions.search`. 

Search provides many front end search functions that enable you to retrieve abbreviated versions of the
data you requested. All GET requests to the SMC API will return an :class:`SMCResult` with attributes set, however
there may be cases where you only want a subset of this information. The search module provides these helper
functions to return the data you need.

Below are some common examples of retrieving data from the SMC:

.. code-block:: python

   #Only return the href of a particular SMC Element:
   smc.actions.search.element_href(name)
   
   #To obtain full json for an SMC Element:
   smc.actions.search.element_as_json(name)
   
   #To obtain full json data and etag information for SMC Element (etag used for modifying an element):
   smc.actions.search.element_as_json_with_etag(name)
   
   #To find all elements by type:
   smc.actions.search.elements_by_type('host')
   
   #To find all available log servers:
   smc.actions.search.log_servers()
   
   #To find all L3 FW policies:
   smc.actions.search.fw_policies()
   
See :py:mod:`smc.actions.search` for more shortcut search options

Tasks
-----

Tasks may be generated by methods within certain classes, for example, many
classes support an export() method. This is an asynchronous task that generates a 
'follower' link to the task. 

It is possible to monitor those asynchronous operations seperately from the direct
method call by getting the follower href and using :py:class:`smc.actions.tasks.TaskMonitor`
or :py:class:`smc.actions.tasks.TaskDownload` classes.

For example, fire off a policy update on an engine and get the asynchronous follower href:

.. code-block:: python

   engine = Engine('myfw').load()
   follower_href = engine.refresh()
   task = TaskMonitor(follower_href).watch()
   for message in task:
     print message


System
------

System level tasks include operations such as checking for and downloading a new
dynamic update, engine upgrades, last activated package, SMC version, SMC time, 
emptying the trash bin, viewing all license details, importing, exporting 
elements and submitting global blacklist entries.

To view any available update packages:

.. code-block:: python
   
   system = System()
   system.update_package() #check all dynamic update packages
   system.update_package_download() #download latest available
   
Empty the trash bin:

.. code-block:: python

   system = System()
   system.empty_trash_bin()

Logging
-------

The smc-python API uses python logging for INFO, ERROR and DEBUG logging levels. If this is required for
longer term logging, add the following to your main class:

.. code-block:: python

   import logging
   logging.getLogger()
   logging.basicConfig(level=logging.ERROR, format='%(asctime)s %(levelname)s: %(message)s')
   
.. note:: This is a recommended setting initially as it enables detailed logging of each call as it is
		  processed through the API. It also includes the backend web based calls initiated by the 
		  requests module.

If you simply require stream logging to console for scripts, from your script import the smc module
set_stream_logger, debug level, and optional format string conforming to the logging module:

.. code-block:: python

   from smc import set_stream_logger
   set_stream_logger(level=logging.DEBUG, format_string=None)
   